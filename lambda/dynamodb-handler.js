/**
 * AWS Lambda Function: DynamoDB Events Handler
 * 
 * This Lambda function handles DynamoDB operations for Events via API Gateway.
 * It uses the Lambda execution role (auto-generated by AWS Academy) to access DynamoDB.
 * 
 * Deployment:
 * 1. Copy this file to Lambda console as index.js (or update handler name)
 * 2. Set handler to: index.handler
 * 3. Set runtime to: Node.js 18.x or later
 * 4. Configure environment variable: EVENTS_TABLE_NAME
 * 5. Attach IAM policy to execution role: dynamodb:GetItem, dynamodb:PutItem, dynamodb:UpdateItem, dynamodb:DeleteItem, dynamodb:Scan
 * 6. Set timeout to 30 seconds
 * 7. Set memory to 256 MB
 * 
 * Note: AWS SDK v2 is built into Lambda runtime, no need to install
 */

const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
const { DynamoDBDocumentClient, GetCommand, PutCommand, UpdateCommand, DeleteCommand, ScanCommand } = require('@aws-sdk/lib-dynamodb');

const client = new DynamoDBClient({});
const dynamodb = DynamoDBDocumentClient.from(client);

/**
 * Lambda handler function
 * @param {Object} event - API Gateway event
 * @param {Object} context - Lambda context
 * @returns {Object} API Gateway response
 */
exports.handler = async (event) => {
  console.log('Received DynamoDB request:', JSON.stringify(event, null, 2));
  
  try {
    // Parse request body
    let body;
    try {
      body = typeof event.body === 'string' ? JSON.parse(event.body) : event.body;
    } catch (parseError) {
      throw new Error('Invalid JSON in request body');
    }
    
    // Get HTTP method and operation
    const httpMethod = event.httpMethod || event.requestContext?.http?.method || 'GET';
    const operation = body.operation || httpMethod.toLowerCase();
    
    // Check if this is an alumni profile operation
    const isAlumniOperation = operation.includes('AlumniProfile') || operation.includes('alumniProfile');
    const tableName = isAlumniOperation 
      ? (process.env.ALUMNI_PROFILES_TABLE_NAME || 'alumni_profiles')
      : (process.env.EVENTS_TABLE_NAME || 'Events');
    
    let result;
    
    // Handle Alumni Profile operations
    if (isAlumniOperation) {
      switch (operation) {
        case 'getAlumniProfile':
          if (!body.userId) {
            throw new Error('userId is required for getAlumniProfile operation');
          }
          
          // Ensure userId is a number (DynamoDB requires exact type match)
          const getUserId = typeof body.userId === 'string' ? parseInt(body.userId, 10) : Number(body.userId);
          if (isNaN(getUserId)) {
            throw new Error('userId must be a valid number');
          }
          
          console.log(`Getting alumni profile for userId: ${getUserId} from table: ${tableName}`);
          
          result = await dynamodb.send(new GetCommand({
            TableName: tableName,
            Key: { userId: getUserId }
          }));
          
          console.log(`DynamoDB get result for userId ${getUserId}:`, {
            hasItem: !!result.Item,
            itemKeys: result.Item ? Object.keys(result.Item) : [],
          });
          
          const responseData = {
            success: true,
            data: result.Item || null,
          };
          
          console.log(`Returning response for userId ${getUserId}:`, {
            success: responseData.success,
            hasData: !!responseData.data,
            dataKeys: responseData.data ? Object.keys(responseData.data) : [],
          });
          
          return {
            statusCode: 200,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify(responseData),
          };
          
        case 'putAlumniProfile':
          if (!body.userId) {
            throw new Error('userId is required for putAlumniProfile operation');
          }
          
          if (!body.profileData) {
            throw new Error('profileData is required for putAlumniProfile operation');
          }
          
          // Ensure userId is a number (DynamoDB requires exact type match)
          const putUserId = typeof body.userId === 'string' ? parseInt(body.userId, 10) : Number(body.userId);
          if (isNaN(putUserId)) {
            throw new Error('userId must be a valid number');
          }
          
          const now = new Date().toISOString();
          
          const existingAlumniProfile = await dynamodb.send(new GetCommand({
            TableName: tableName,
            Key: { userId: putUserId }
          }));
          
          const alumniProfileData = {
            userId: putUserId,
            skills: body.profileData.skills || [],
            aspirations: body.profileData.aspirations || null,
            bio: body.profileData.bio || null,
            major: body.profileData.major || null,
            grad_year: body.profileData.grad_year || null,
            relevant_coursework: body.profileData.relevant_coursework || [],
            parsed_resume: body.profileData.parsed_resume || null,
            projects: body.profileData.projects || [],
            experiences: body.profileData.experiences || [],
            achievements: body.profileData.achievements || [],
            resume_url: body.profileData.resume_url || null,
            linkedin_url: body.profileData.linkedin_url || null,
            github_url: body.profileData.github_url || null,
            location: body.profileData.location || null,
            updatedAt: now,
          };
          
          if (existingAlumniProfile.Item && existingAlumniProfile.Item.createdAt) {
            alumniProfileData.createdAt = existingAlumniProfile.Item.createdAt;
          } else {
            alumniProfileData.createdAt = now;
          }
          
          await dynamodb.send(new PutCommand({
            TableName: tableName,
            Item: alumniProfileData,
          }));
          
          return {
            statusCode: 200,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              success: true,
              data: alumniProfileData,
            }),
          };
          
        case 'updateAlumniProfile':
          if (!body.userId) {
            throw new Error('userId is required for updateAlumniProfile operation');
          }
          
          // Ensure userId is a number
          const updateUserId = typeof body.userId === 'string' ? parseInt(body.userId, 10) : Number(body.userId);
          if (isNaN(updateUserId)) {
            throw new Error('userId must be a valid number');
          }
          
          const alumniProfileToUpdate = await dynamodb.send(new GetCommand({
            TableName: tableName,
            Key: { userId: updateUserId }
          }));
          
          if (!alumniProfileToUpdate.Item) {
            return {
              statusCode: 404,
              headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
              },
              body: JSON.stringify({
                success: false,
                error: 'Alumni profile not found',
              }),
            };
          }
          
          const alumniUpdateExpressions = [];
          const alumniExpressionAttributeNames = {};
          const alumniExpressionAttributeValues = {};
          
          const alumniUpdateFields = ['skills', 'aspirations', 'bio', 'major', 'grad_year', 'relevant_coursework', 'parsed_resume', 'projects', 'experiences', 'achievements', 'resume_url', 'linkedin_url', 'github_url', 'location'];
          alumniUpdateFields.forEach((field, index) => {
            if (body.profileData && body.profileData[field] !== undefined) {
              const nameKey = `#attr${index}`;
              const valueKey = `:val${index}`;
              alumniUpdateExpressions.push(`${nameKey} = ${valueKey}`);
              alumniExpressionAttributeNames[nameKey] = field;
              alumniExpressionAttributeValues[valueKey] = body.profileData[field];
            }
          });
          
          const alumniUpdatedAtKey = `#attr${alumniUpdateExpressions.length}`;
          const alumniUpdatedAtValue = `:val${alumniUpdateExpressions.length}`;
          alumniUpdateExpressions.push(`${alumniUpdatedAtKey} = ${alumniUpdatedAtValue}`);
          alumniExpressionAttributeNames[alumniUpdatedAtKey] = 'updatedAt';
          alumniExpressionAttributeValues[alumniUpdatedAtValue] = new Date().toISOString();
          
          if (alumniUpdateExpressions.length === 0) {
            throw new Error('No fields to update');
          }
          
          const alumniUpdateResult = await dynamodb.send(new UpdateCommand({
            TableName: tableName,
            Key: { userId: updateUserId },
            UpdateExpression: `SET ${alumniUpdateExpressions.join(', ')}`,
            ExpressionAttributeNames: alumniExpressionAttributeNames,
            ExpressionAttributeValues: alumniExpressionAttributeValues,
            ReturnValues: 'ALL_NEW',
          }));
          
          return {
            statusCode: 200,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              success: true,
              data: alumniUpdateResult.Attributes,
            }),
          };
          
        case 'deleteAlumniProfile':
          if (!body.userId) {
            throw new Error('userId is required for deleteAlumniProfile operation');
          }
          
          // Ensure userId is a number
          const deleteUserId = typeof body.userId === 'string' ? parseInt(body.userId, 10) : Number(body.userId);
          if (isNaN(deleteUserId)) {
            throw new Error('userId must be a valid number');
          }
          
          const alumniProfileToDelete = await dynamodb.send(new GetCommand({
            TableName: tableName,
            Key: { userId: deleteUserId }
          }));
          
          if (!alumniProfileToDelete.Item) {
            return {
              statusCode: 404,
              headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
              },
              body: JSON.stringify({
                success: false,
                error: 'Alumni profile not found',
              }),
            };
          }
          
          await dynamodb.send(new DeleteCommand({
            TableName: tableName,
            Key: { userId: deleteUserId }
          }));
          
          return {
            statusCode: 200,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              success: true,
              message: 'Alumni profile deleted successfully',
            }),
          };
          
        default:
          throw new Error(`Unsupported alumni operation: ${operation}`);
      }
    }
    
    // Handle Events operations (existing code)
    switch (operation) {
      case 'get':
      case 'GET':
        // Get event by ID
        if (!body.eventId) {
          throw new Error('eventId is required for get operation');
        }
        result = await dynamodb.send(new GetCommand({
          TableName: tableName,
          Key: { eventId: body.eventId }
        }));
        
        return {
          statusCode: 200,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
          },
          body: JSON.stringify({
            success: true,
            data: result.Item || null,
          }),
        };
        
      case 'getAll':
      case 'scan':
        // Get all events (works with any HTTP method)
        const scanResult = await dynamodb.send(new ScanCommand({
          TableName: tableName,
        }));
        
        return {
          statusCode: 200,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
          },
          body: JSON.stringify({
            success: true,
            data: scanResult.Items || [],
          }),
        };
        
      case 'getCompetitions':
        // Get all events with type="competition"
        const competitionsScanResult = await dynamodb.send(new ScanCommand({
          TableName: tableName,
        }));
        
        // Filter events where type="competition"
        // Check both event.type and event.eventInfo.type
        const competitions = (competitionsScanResult.Items || []).filter((event) => {
          return event.type === 'competition' || 
                 (event.eventInfo && event.eventInfo.type === 'competition');
        });
        
        return {
          statusCode: 200,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
          },
          body: JSON.stringify({
            success: true,
            data: competitions,
          }),
        };
        
      case 'create':
      case 'POST':
        // Create new event
        // Support both old format (title/description) and new format (eventInfo)
        const hasOldFormat = body.title && body.description;
        const hasNewFormat = body.eventInfo && body.eventInfo.name && body.eventInfo.description;
        
        if (!hasOldFormat && !hasNewFormat) {
          throw new Error('Either (title and description) or (eventInfo with name and description) is required for create operation');
        }
        
        // Generate event ID
        const eventId = body.eventId || `EVT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const now = new Date().toISOString();
        
        // Build eventInfo from either format
        let eventInfo;
        if (hasNewFormat) {
          eventInfo = body.eventInfo;
        } else {
          // Convert old format to new format
          eventInfo = {
            name: body.title,
            description: body.description,
            ...(body.photos && { photos: body.photos }),
            ...(body.date && { date: body.date }),
          };
        }
        
        const newEvent = {
          eventId,
          eventInfo: eventInfo || {},
          teams: body.teams || [],
          rubrics: body.rubrics || [],
          judges: body.judges || [],
          scores: body.scores || [],
          createdAt: now,
          updatedAt: now,
        };
        
        await dynamodb.send(new PutCommand({
          TableName: tableName,
          Item: newEvent,
        }));
        
        return {
          statusCode: 201,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
          },
          body: JSON.stringify({
            success: true,
            data: newEvent,
          }),
        };
        
      case 'update':
      case 'PUT':
        // Update existing event
        if (!body.eventId) {
          throw new Error('eventId is required for update operation');
        }
        
        // Check if event exists
        const existingEvent = await dynamodb.send(new GetCommand({
          TableName: tableName,
          Key: { eventId: body.eventId }
        }));
        
        if (!existingEvent.Item) {
          return {
            statusCode: 404,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              success: false,
              error: 'Event not found',
            }),
          };
        }
        
        // Build update expression
        const updateExpressions = [];
        const expressionAttributeNames = {};
        const expressionAttributeValues = {};
        
        const updateFields = ['title', 'description', 'photos', 'rubric', 'slots', 'teams'];
        updateFields.forEach((field, index) => {
          if (body[field] !== undefined) {
            const nameKey = `#attr${index}`;
            const valueKey = `:val${index}`;
            updateExpressions.push(`${nameKey} = ${valueKey}`);
            expressionAttributeNames[nameKey] = field;
            expressionAttributeValues[valueKey] = body[field];
          }
        });
        
        // Always update updatedAt
        const updatedAtKey = `#attr${updateExpressions.length}`;
        const updatedAtValue = `:val${updateExpressions.length}`;
        updateExpressions.push(`${updatedAtKey} = ${updatedAtValue}`);
        expressionAttributeNames[updatedAtKey] = 'updatedAt';
        expressionAttributeValues[updatedAtValue] = new Date().toISOString();
        
        if (updateExpressions.length === 0) {
          throw new Error('No fields to update');
        }
        
        const updateResult = await dynamodb.send(new UpdateCommand({
          TableName: tableName,
          Key: { eventId: body.eventId },
          UpdateExpression: `SET ${updateExpressions.join(', ')}`,
          ExpressionAttributeNames: expressionAttributeNames,
          ExpressionAttributeValues: expressionAttributeValues,
          ReturnValues: 'ALL_NEW',
        }));
        
        return {
          statusCode: 200,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
          },
          body: JSON.stringify({
            success: true,
            data: updateResult.Attributes,
          }),
        };
        
      case 'updateScores':
        // Replace the entire scores array (updates existing scores or adds new ones)
        if (!body.eventId) {
          throw new Error('eventId is required for updateScores operation');
        }
        
        if (!body.scores || !Array.isArray(body.scores)) {
          throw new Error('scores must be an array');
        }
        
        // Check if event exists
        const eventForScores = await dynamodb.send(new GetCommand({
          TableName: tableName,
          Key: { eventId: body.eventId }
        }));
        
        if (!eventForScores.Item) {
          return {
            statusCode: 404,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              success: false,
              error: 'Event not found',
            }),
          };
        }
        
        // Replace the entire scores array (allows updating existing scores)
        const updateScoresResult = await dynamodb.send(new UpdateCommand({
          TableName: tableName,
          Key: { eventId: body.eventId },
          UpdateExpression: 'SET #scores = :scores, #updatedAt = :updatedAt',
          ExpressionAttributeNames: {
            '#scores': 'scores',
            '#updatedAt': 'updatedAt',
          },
          ExpressionAttributeValues: {
            ':scores': body.scores,
            ':updatedAt': new Date().toISOString(),
          },
          ReturnValues: 'ALL_NEW',
        }));
        
        return {
          statusCode: 200,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
          },
          body: JSON.stringify({
            success: true,
            data: updateScoresResult.Attributes,
          }),
        };
        
      case 'delete':
      case 'DELETE':
        // Delete event
        if (!body.eventId) {
          throw new Error('eventId is required for delete operation');
        }
        
        // Check if event exists
        const eventToDelete = await dynamodb.send(new GetCommand({
          TableName: tableName,
          Key: { eventId: body.eventId }
        }));
        
        if (!eventToDelete.Item) {
          return {
            statusCode: 404,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              success: false,
              error: 'Event not found',
            }),
          };
        }
        
        await dynamodb.send(new DeleteCommand({
          TableName: tableName,
          Key: { eventId: body.eventId }
        }));
        
        return {
          statusCode: 200,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
          },
          body: JSON.stringify({
            success: true,
            message: 'Event deleted successfully',
          }),
        };
        
      default:
        throw new Error(`Unsupported operation: ${operation}`);
    }
    
    // Fallback for unsupported operations
    throw new Error(`Unsupported operation: ${operation}`);
    
  } catch (error) {
    console.error('DynamoDB operation error:', error);
    
    return {
      statusCode: error.statusCode || 500,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
      },
      body: JSON.stringify({
        success: false,
        error: error.message || 'Failed to process DynamoDB operation',
      }),
    };
  }
};

